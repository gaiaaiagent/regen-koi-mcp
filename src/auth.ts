/**
 * Authentication Module
 * Manages session tokens for authenticated API calls
 *
 * SECURITY: This module stores session tokens (NOT Google OAuth tokens).
 * Session tokens are generated by our server and only work with our API.
 * They are safe to store locally - even if leaked, they can't be used
 * to access Google APIs or impersonate the user elsewhere.
 */

import { execSync } from 'child_process';
import { logger } from './logger.js';

// Determine user email for authentication context
function determineUserEmail(): string {
  // Check environment variables first
  if (process.env.REGEN_USER_EMAIL) return process.env.REGEN_USER_EMAIL;
  if (process.env.USER_EMAIL) return process.env.USER_EMAIL;

  // Try to get from git config
  try {
    const email = execSync('git config user.email').toString().trim();
    if (email) return email;
  } catch (e) {
    // Git config not available
  }

  // Fall back to system user
  return `${process.env.USER || 'unknown'}@local`;
}

export const USER_EMAIL = determineUserEmail();

// Cache for storing session tokens
interface SessionCacheEntry {
  sessionToken: string;
  expiresAt: number;
}

const sessionCache = new Map<string, SessionCacheEntry>();

// Stored session token (persisted in memory for the MCP session)
let storedSessionToken: string | null = null;
let storedTokenExpiry: number | null = null;

/**
 * Get the current session token (if any)
 * Returns null if no token is stored or if expired
 */
export function getSessionToken(): string | null {
  // Check if stored token has expired
  if (storedSessionToken && storedTokenExpiry && storedTokenExpiry <= Date.now()) {
    logger.info({ action: 'session_token_expired', email: USER_EMAIL }, 'Session token expired');
    storedSessionToken = null;
    storedTokenExpiry = null;
    return null;
  }
  return storedSessionToken;
}

// Alias for backwards compatibility
export const getAccessToken = getSessionToken;

/**
 * Store session token after successful OAuth
 * @param token - The session token from our server (NOT Google OAuth token)
 * @param expiresAt - Expiry timestamp
 */
export function setSessionToken(token: string, expiresAt?: number): void {
  storedSessionToken = token;
  storedTokenExpiry = expiresAt || Date.now() + 60 * 60 * 1000; // Default 1 hour
  sessionCache.set(USER_EMAIL, {
    sessionToken: token,
    expiresAt: storedTokenExpiry
  });
  logger.info({ action: 'session_token_stored', email: USER_EMAIL }, 'Session token stored (safe - not a Google token)');
}

// Alias for backwards compatibility
export const setAccessToken = setSessionToken;

/**
 * Clear session token (called when token is invalid or on logout)
 */
export function clearAuthCache(): void {
  sessionCache.delete(USER_EMAIL);
  storedSessionToken = null;
  storedTokenExpiry = null;
  logger.info({ action: 'session_cleared', email: USER_EMAIL }, 'Session cleared');
}

/**
 * Check if we have a valid session token
 */
export function hasSessionToken(): boolean {
  return getSessionToken() !== null;
}

// Alias for backwards compatibility
export const hasAccessToken = hasSessionToken;
